import 'dart:typed_data';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

/// Service for generating PDF documents from report markdown content.
class PdfGeneratorService {
  /// Generates a professionally formatted PDF from owner report content.
  static Future<Uint8List> generateOwnerReportPdf({
    required String reportContent,
    required String companyName,
    required String dateRange,
    required List<String> projectNames,
  }) async {
    final pdf = pw.Document(
      theme: pw.ThemeData.withFont(),
    );

    // Parse markdown into sections
    final sections = _parseMarkdown(reportContent);

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        margin: const pw.EdgeInsets.all(40),
        header: (context) => _buildHeader(companyName, dateRange, context),
        footer: (context) => _buildFooter(context),
        build: (context) => _buildContent(sections, projectNames),
      ),
    );

    return pdf.save();
  }

  static pw.Widget _buildHeader(
    String companyName,
    String dateRange,
    pw.Context context,
  ) {
    if (context.pageNumber > 1) {
      return pw.Container(
        margin: const pw.EdgeInsets.only(bottom: 10),
        child: pw.Row(
          mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
          children: [
            pw.Text(
              companyName,
              style: pw.TextStyle(
                fontSize: 9,
                color: PdfColors.grey600,
                fontWeight: pw.FontWeight.bold,
              ),
            ),
            pw.Text(
              dateRange,
              style: const pw.TextStyle(fontSize: 9, color: PdfColors.grey600),
            ),
          ],
        ),
      );
    }

    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 20),
      padding: const pw.EdgeInsets.only(bottom: 15),
      decoration: const pw.BoxDecoration(
        border: pw.Border(
          bottom: pw.BorderSide(color: PdfColors.indigo800, width: 2),
        ),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            'PROJECT PROGRESS REPORT',
            style: pw.TextStyle(
              fontSize: 22,
              fontWeight: pw.FontWeight.bold,
              color: PdfColors.indigo800,
            ),
          ),
          pw.SizedBox(height: 6),
          pw.Text(
            'Period: $dateRange',
            style: const pw.TextStyle(fontSize: 12, color: PdfColors.grey700),
          ),
          pw.SizedBox(height: 2),
          pw.Text(
            'Prepared by: $companyName',
            style: const pw.TextStyle(fontSize: 12, color: PdfColors.grey700),
          ),
        ],
      ),
    );
  }

  static pw.Widget _buildFooter(pw.Context context) {
    return pw.Container(
      margin: const pw.EdgeInsets.only(top: 10),
      decoration: const pw.BoxDecoration(
        border: pw.Border(
          top: pw.BorderSide(color: PdfColors.grey300, width: 0.5),
        ),
      ),
      padding: const pw.EdgeInsets.only(top: 8),
      child: pw.Row(
        mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
        children: [
          pw.Text(
            'Generated by SiteVoice',
            style: const pw.TextStyle(fontSize: 8, color: PdfColors.grey500),
          ),
          pw.Text(
            'Page ${context.pageNumber} of ${context.pagesCount}',
            style: const pw.TextStyle(fontSize: 8, color: PdfColors.grey500),
          ),
        ],
      ),
    );
  }

  static List<pw.Widget> _buildContent(
    List<_MarkdownSection> sections,
    List<String> projectNames,
  ) {
    final widgets = <pw.Widget>[];

    for (final section in sections) {
      switch (section.type) {
        case _SectionType.heading1:
          widgets.add(pw.SizedBox(height: 16));
          widgets.add(pw.Text(
            section.text,
            style: pw.TextStyle(
              fontSize: 18,
              fontWeight: pw.FontWeight.bold,
              color: PdfColors.indigo800,
            ),
          ));
          widgets.add(pw.SizedBox(height: 8));
          break;

        case _SectionType.heading2:
          widgets.add(pw.SizedBox(height: 14));
          widgets.add(pw.Container(
            padding: const pw.EdgeInsets.only(bottom: 4),
            decoration: const pw.BoxDecoration(
              border: pw.Border(
                bottom: pw.BorderSide(color: PdfColors.indigo200, width: 1),
              ),
            ),
            child: pw.Text(
              section.text,
              style: pw.TextStyle(
                fontSize: 14,
                fontWeight: pw.FontWeight.bold,
                color: PdfColors.indigo800,
              ),
            ),
          ));
          widgets.add(pw.SizedBox(height: 6));
          break;

        case _SectionType.heading3:
          widgets.add(pw.SizedBox(height: 10));
          widgets.add(pw.Text(
            section.text,
            style: pw.TextStyle(
              fontSize: 12,
              fontWeight: pw.FontWeight.bold,
              color: PdfColors.grey800,
            ),
          ));
          widgets.add(pw.SizedBox(height: 4));
          break;

        case _SectionType.bullet:
          widgets.add(pw.Padding(
            padding: const pw.EdgeInsets.only(left: 12, top: 2, bottom: 2),
            child: pw.Row(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Container(
                  width: 4,
                  height: 4,
                  margin: const pw.EdgeInsets.only(top: 5, right: 8),
                  decoration: const pw.BoxDecoration(
                    shape: pw.BoxShape.circle,
                    color: PdfColors.indigo600,
                  ),
                ),
                pw.Expanded(
                  child: _buildRichText(section.text, 10),
                ),
              ],
            ),
          ));
          break;

        case _SectionType.checkBullet:
          widgets.add(pw.Padding(
            padding: const pw.EdgeInsets.only(left: 12, top: 2, bottom: 2),
            child: pw.Row(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Text(
                  '\u2713 ',
                  style: pw.TextStyle(
                    fontSize: 11,
                    fontWeight: pw.FontWeight.bold,
                    color: PdfColors.green700,
                  ),
                ),
                pw.Expanded(
                  child: _buildRichText(section.text, 10),
                ),
              ],
            ),
          ));
          break;

        case _SectionType.paragraph:
          widgets.add(pw.Padding(
            padding: const pw.EdgeInsets.symmetric(vertical: 3),
            child: _buildRichText(section.text, 10),
          ));
          break;

        case _SectionType.divider:
          widgets.add(pw.SizedBox(height: 8));
          widgets.add(pw.Divider(color: PdfColors.grey300));
          widgets.add(pw.SizedBox(height: 8));
          break;
      }
    }

    return widgets;
  }

  /// Build a pw.RichText that handles **bold** markers.
  static pw.Widget _buildRichText(String text, double fontSize) {
    final spans = <pw.InlineSpan>[];
    final parts = text.split('**');

    for (int i = 0; i < parts.length; i++) {
      if (parts[i].isEmpty) continue;
      final isBold = i % 2 == 1;
      spans.add(pw.TextSpan(
        text: parts[i],
        style: pw.TextStyle(
          fontSize: fontSize,
          fontWeight: isBold ? pw.FontWeight.bold : pw.FontWeight.normal,
          color: PdfColors.grey800,
        ),
      ));
    }

    if (spans.isEmpty) {
      return pw.Text(
        text,
        style: pw.TextStyle(fontSize: fontSize, color: PdfColors.grey800),
      );
    }

    return pw.RichText(text: pw.TextSpan(children: spans));
  }

  /// Parse markdown text into structured sections.
  static List<_MarkdownSection> _parseMarkdown(String markdown) {
    final sections = <_MarkdownSection>[];
    final lines = markdown.split('\n');

    for (final line in lines) {
      final trimmed = line.trim();

      if (trimmed.isEmpty) continue;

      if (trimmed.startsWith('### ')) {
        sections.add(_MarkdownSection(_SectionType.heading3, trimmed.substring(4)));
      } else if (trimmed.startsWith('## ')) {
        sections.add(_MarkdownSection(_SectionType.heading2, trimmed.substring(3)));
      } else if (trimmed.startsWith('# ')) {
        sections.add(_MarkdownSection(_SectionType.heading1, trimmed.substring(2)));
      } else if (trimmed == '---' || trimmed == '***' || trimmed == '___') {
        sections.add(_MarkdownSection(_SectionType.divider, ''));
      } else if (trimmed.startsWith('- \u2713') || trimmed.startsWith('- \u2714') || trimmed.startsWith('- \u2705')) {
        // Checkmark bullets: - ✓, - ✔, - ✅
        final text = trimmed.substring(3).trim();
        sections.add(_MarkdownSection(_SectionType.checkBullet, text));
      } else if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
        sections.add(_MarkdownSection(_SectionType.bullet, trimmed.substring(2)));
      } else {
        sections.add(_MarkdownSection(_SectionType.paragraph, trimmed));
      }
    }

    return sections;
  }
}

enum _SectionType { heading1, heading2, heading3, bullet, checkBullet, paragraph, divider }

class _MarkdownSection {
  final _SectionType type;
  final String text;
  _MarkdownSection(this.type, this.text);
}
